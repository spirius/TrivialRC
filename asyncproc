#!/bin/bash

# --- Main ---
asyncproc_start() {
    asyncproc_init
    asyncproc_say "Starting..."
    asyncproc_handler_ec_start
    asyncproc_handler_stdout_start
    asyncproc_handler_stderr_start
    asyncproc_say "Ready to run processes"
}

asyncproc_init() {
    asyncproc_conf
    declare -F asyncproc_conf_local &> /dev/null && asyncproc_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_INPUT}"
    exec 5<>${ASYNCPROC_INPUT}
}

asyncproc_conf() {
    asyncproc_basename="$(basename -s .sh $0)"
    asyncproc_namespace="main"
    export ASYNCPROC_INPUT="/tmp/${asyncproc_basename}-asyncproc.pipe"
    asyncproc_say_pre='$(date "+%Y-%m-%d %H:%M:%S") ${asyncproc_basename} [asyncproc-${asyncproc_namespace}/$BASHPID]: '
    asyncproc_err_pre="error: "
    asyncproc_die_exitcode="13"
    asyncproc_handlers=()
    asyncproc_kill_timeout="16"
    asyncproc_async_pids=()

    asyncproc_workers=()
    asyncproc_exitcodes=()
    asyncproc_stdouts=()
    asyncproc_stderrs=()
}

asyncproc_exit() {
    asyncproc_get_exitcodes "close"
    asyncproc_get_stdouts "close"
    asyncproc_get_stderrs "close"

    asyncproc_term_procs ${asyncproc_kill_timeout} ${asyncproc_handlers[*]} &>/dev/null
    
    exec 5>&-
    rm -f ${ASYNCPROC_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_INPUT}"

    asyncproc_say "Workers: ${asyncproc_workers[*]}"
    asyncproc_say "Exit codes: ${asyncproc_exitcodes[*]}"
    asyncproc_say "Files with Stdout: ${asyncproc_stdouts[*]}"
    asyncproc_say "Files with Stderr: ${asyncproc_stderrs[*]}"
    asyncproc_say "Stopped"
}

asyncproc_run() {
    :
}

# --- Exit Code handler ---
asyncproc_handler_ec_start() {
    asyncproc_handler_ec_init
    (
        trap asyncproc_handler_ec_exit EXIT
        asyncproc_namespace="ec"
        local _pid _ec _ec_k _ecs=()

        asyncproc_say "Ready to receive exit codes at ${ASYNCPROC_HANDLER_EC_INPUT}"

        while :; do
            [[ -p ${ASYNCPROC_HANDLER_EC_INPUT} ]] || asyncproc_die "Cannot read from ${ASYNCPROC_HANDLER_EC_INPUT}"
            read -u 6 _pid _ec
            if [[ -n "${_pid}" ]]; then
                if [[ "${_pid}" = "dump" ]] || [[ "${_pid}" = "close" ]]; then
                    for _ec_k in ${!_ecs[*]}; do
                        echo "${_ec_k} ${_ecs[${_ec_k}]}" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                        unset _ecs[${_ec_k}]
                    done
                    echo "end" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                    [[ "${_pid}" = "close" ]] && exit
                elif [[ ${_pid} -gt 0 ]] && [[ -n "${_ec}" ]] && [[ ${_ec} -ge 0 ]]; then
                    _ecs[${_pid}]=${_ec}
                fi
            fi
        done
    )&
    asyncproc_handlers[${#asyncproc_handlers[*]}]=$!
    asyncproc_say "Exitcode handler has been started as ${asyncproc_handlers[-1]}"
}

asyncproc_handler_ec_init() {
    asyncproc_handler_ec_conf
    declare -F asyncproc_handler_ec_conf_local &> /dev/null && asyncproc_handler_ec_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_HANDLER_EC_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_HANDLER_EC_INPUT}"
    exec 6<>${ASYNCPROC_HANDLER_EC_INPUT}
}

asyncproc_handler_ec_conf() {
    export ASYNCPROC_HANDLER_EC_INPUT="/tmp/${asyncproc_basename}-asyncproc-ec.pipe"
}

asyncproc_handler_ec_exit() {
    exec 6>&-
    rm -f ${ASYNCPROC_HANDLER_EC_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_HANDLER_EC_INPUT}"
    asyncproc_say "Exitcode handler has exited"
}


# --- Stdout handler ---
asyncproc_handler_stdout_start() {
    asyncproc_handler_stdout_init
    (
        trap asyncproc_handler_stdout_exit EXIT
        asyncproc_namespace="stdout"
        local _pid _stdout _stdout_k _stdouts=()

        asyncproc_say "Ready to receive stdouts at ${ASYNCPROC_HANDLER_STDOUT_INPUT}"

        while :; do
            [[ -p ${ASYNCPROC_HANDLER_STDOUT_INPUT} ]] || asyncproc_die "Cannot read from ${ASYNCPROC_HANDLER_STDOUT_INPUT}"
            read -u 7 _pid _stdout
            if [[ -n "${_pid}" ]]; then
                if [[ "${_pid}" = "dump" ]] || [[ "${_pid}" = "close" ]]; then
                    for _stdout_k in ${!_stdouts[*]}; do
                        echo "${_stdout_k} \"${_stdouts[${_stdout_k}]}\"" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                        unset _stdouts[${_stdout_k}]
                    done
                    echo "end" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                    [[ "${_pid}" = "close" ]] && exit
                elif [[ ${_pid} -gt 0 ]] && [[ -n "${_stdout}" ]]; then
                    _stdouts[${_pid}]="${_stdout}"
                fi
            fi
        done
    )&
    asyncproc_handlers[${#asyncproc_handlers[*]}]=$!
    asyncproc_say "Stdout handler has been started as ${asyncproc_handlers[-1]}" 
}

asyncproc_handler_stdout_init() {
    asyncproc_handler_stdout_conf
    declare -F asyncproc_handler_stdout_conf_local &> /dev/null && asyncproc_handler_stdout_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_HANDLER_STDOUT_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_HANDLER_STDOUT_INPUT}"
    exec 7<>${ASYNCPROC_HANDLER_STDOUT_INPUT}
}

asyncproc_handler_stdout_conf() {
    export ASYNCPROC_HANDLER_STDOUT_INPUT="/tmp/${asyncproc_basename}-asyncproc-stdout.pipe"
}

asyncproc_handler_stdout_exit() {
    exec 7>&-
    rm -f ${ASYNCPROC_HANDLER_STDOUT_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_HANDLER_STDOUT_INPUT}"
    asyncproc_say "Stdout handler has exited"
}


# --- Stderr handler ---
asyncproc_handler_stderr_start() {
    asyncproc_handler_stderr_init
    (
        trap asyncproc_handler_stderr_exit EXIT
        asyncproc_namespace="stderr"
        local _pid _stderr _stderr_k _stderrs=()

        asyncproc_say "Ready to receive stderrs at ${ASYNCPROC_HANDLER_STDERR_INPUT}"

        while :; do
            [[ -p ${ASYNCPROC_HANDLER_STDERR_INPUT} ]] || asyncproc_die "Cannot read from ${ASYNCPROC_HANDLER_STDERR_INPUT}"
            read -u 8 _pid _stderr
            if [[ -n "${_pid}" ]]; then
                if [[ "${_pid}" = "dump" ]] || [[ "${_pid}" = "close" ]]; then
                    for _stderr_k in ${!_stderrs[*]}; do
                        echo "${_stderr_k} ${_stderrs[${_stderr_k}]}" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                        unset _stderrs[${_stderr_k}]
                    done
                    echo "end" > ${ASYNCPROC_INPUT} || asyncproc_die "Cannot write to ${ASYNCPROC_INPUT}"
                    [[ "${_pid}" = "close" ]] && exit
                elif [[ ${_pid} -gt 0 ]] && [[ -n "${_stderr}" ]]; then
                    _stderrs[${_pid}]="${_stderr}"
                fi
            fi
        done
    )&
    asyncproc_handlers[${#asyncproc_handlers[*]}]=$!
    asyncproc_say "Stderr handler has been started as ${asyncproc_handlers[-1]}" 
}

asyncproc_handler_stderr_init() {
    asyncproc_handler_stderr_conf
    declare -F asyncproc_handler_stderr_conf_local &> /dev/null && asyncproc_handler_stderr_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_HANDLER_STDERR_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_HANDLER_STDERR_INPUT}"
    exec 8<>${ASYNCPROC_HANDLER_STDERR_INPUT}
}

asyncproc_handler_stderr_conf() {
    export ASYNCPROC_HANDLER_STDERR_INPUT="/tmp/${asyncproc_basename}-asyncproc-stderr.pipe"
}

asyncproc_handler_stderr_exit() {
    exec 8>&-
    rm -f ${ASYNCPROC_HANDLER_STDERR_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_HANDLER_STDERR_INPUT}"
    asyncproc_say "Stderr handler has exited"
}

# --- Common functions ---
asyncproc_say() {
    if [[ "${ASYNCPROC_VERBOSE}" = "true" ]]; then
        eval echo "${asyncproc_say_pre}$@${asyncproc_say_suf}"
    fi
}

asyncproc_err() {
    asyncproc_say "${asyncproc_err_pre}$@${asyncproc_err_suf}" >&2
}

asyncproc_die() {
    asyncproc_err "${asyncproc_die_pre}$@${asyncproc_die_suf}"
    exit ${asyncproc_die_exitcode}
}

asyncproc_term_procs() {
    local _kill_timeout _pid_k _pids=() _watchdog=()

    _kill_timeout=$1; shift
    read -a _pids <<< "$@"

    while [[ -n "${!_pids[*]}" ]]; do
        for _pid_k in ${!_pids[*]}; do
            if [[ -z "${_pids[${_pid_k}]}" ]] || [[ ${_pids[${_pid_k}]} -eq 0 ]]; then
                unset _pids[${_pid_k}]
                continue
            fi
            
            if ps -p ${_pids[${_pid_k}]} &>/dev/null; then
                if [[ -n "${_watchdog[${_pids[${_pid_k}]}]}" ]] && [[ ${_watchdog[${_pids[${_pid_k}]}]} -gt 0 ]]; then
                    :
                else
                    kill -TERM ${_pids[${_pid_k}]}
                    ( sleep ${_kill_timeout}; kill -KILL ${_pids[${_pid_k}]} )&
                    # saving watchdog's PID in the index of process' PID
                    _watchdog[${_pids[${_pid_k}]}]=$!
                fi
            else 
                ps -p ${_watchdog[${_pids[${_pid_k}]}]} &>/dev/null && kill -TERM ${_watchdog[${_pids[${_pid_k}]}]}
                unset _wd[${_pids[${_pid_k}]}]
                unset _pids[${_pid_k}]
            fi
        done
        sleep 1
    done
}

asyncproc_get_exitcodes() {
    local _pid _ec

    if [[ -p ${ASYNCPROC_INPUT} ]] && [[ -p ${ASYNCPROC_HANDLER_EC_INPUT} ]]; then
        echo "$1" > ${ASYNCPROC_HANDLER_EC_INPUT}
        while read -u 5 _pid _ec; do
            if [[ "${_pid}" = "end" ]]; then
                break
            else
                asyncproc_exitcodes[${_pid}]=${_ec}
            fi
        done
    fi
}

asyncproc_get_stdouts() {
    local _pid _stdout

    if [[ -p ${ASYNCPROC_INPUT} ]] && [[ -p ${ASYNCPROC_HANDLER_STDOUT_INPUT} ]]; then
        echo "$1" > ${ASYNCPROC_HANDLER_STDOUT_INPUT}
        while read -u 5 _pid _stdout; do
            if [[ "${_pid}" = "end" ]]; then
                break
            else
                asyncproc_stdouts[${_pid}]="${_stdout}"
            fi
        done
    fi
}

asyncproc_get_stderrs() {
    local _pid _stderr

    if [[ -p ${ASYNCPROC_INPUT} ]] && [[ -p ${ASYNCPROC_HANDLER_STDERR_INPUT} ]]; then
        echo "$1" > ${ASYNCPROC_HANDLER_STDERR_INPUT}
        while read -u 5 _pid _stderr; do
            if [[ "${_pid}" = "end" ]]; then
                break
            else
                asyncproc_stderrs[${_pid}]="${_stderr}"
            fi
        done
    fi
}

