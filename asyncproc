#!/bin/bash

# --- Main ---
asyncproc_start() {
    asyncproc_init
    asyncproc_say "Starting..."
    asyncproc_handler_ec_start
    asyncproc_handler_stdout_start
    asyncproc_handler_stderr_start
    asyncproc_say "Ready to run processes"
}

asyncproc_init() {
    asyncproc_conf
    declare -F asyncproc_conf_local &> /dev/null && asyncproc_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_INPUT}"
}

asyncproc_conf() {
    asyncproc_basename="$(basename -s .sh $0)"
    asyncproc_namespace="main"
    export ASYNCPROC_INPUT="/tmp/${asyncproc_basename}-asyncproc.pipe"
    asyncproc_say_pre='$(date "+%Y-%m-%d %H:%M:%S") ${asyncproc_basename} [asyncproc-${asyncproc_namespace}/$BASHPID]: '
    asyncproc_err_pre="error: "
    asyncproc_die_exitcode="1"
    asyncproc_handlers=()
    asyncproc_term_timeout="6"
}

asyncproc_exit() {
    asyncproc_term_procs ${asyncproc_term_timeout} ${asyncproc_handlers[*]} &>/dev/null
    rm -f ${ASYNCPROC_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_INPUT}"
    asyncproc_say "Stopped"
}

asyncproc_run() {
    :
}

# --- Exit Code handler ---
asyncproc_handler_ec_start() {
    asyncproc_handler_ec_init
    (
        trap asyncproc_handler_ec_exit EXIT
        asyncproc_namespace="ec"
        asyncproc_say "Ready to receive exit codes at ${ASYNCPROC_HANDLER_EC_INPUT}"

        sleep 14
    )&
    asyncproc_handlers[${#asyncproc_handlers[*]}]=$!
    asyncproc_say "Exitcode handler has been started as ${asyncproc_handlers[-1]}"
}

asyncproc_handler_ec_init() {
    asyncproc_handler_ec_conf
    declare -F asyncproc_handler_ec_conf_local &> /dev/null && asyncproc_handler_ec_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_HANDLER_EC_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_HANDLER_EC_INPUT}"
}

asyncproc_handler_ec_conf() {
    asyncproc_handler_ec_pid="0"
    export ASYNCPROC_HANDLER_EC_INPUT="/tmp/${asyncproc_basename}-asyncproc-ec.pipe"
}

asyncproc_handler_ec_exit() {
    rm -f ${ASYNCPROC_HANDLER_EC_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_HANDLER_EC_INPUT}"
    asyncproc_say "Exitcode handler has exited"
}


# --- Stdout handler ---
asyncproc_handler_stdout_start() {
    asyncproc_handler_stdout_init
    (
        trap asyncproc_handler_stdout_exit EXIT
        asyncproc_namespace="stdout"
        asyncproc_say "Ready to receive stdouts at ${ASYNCPROC_HANDLER_STDOUT_INPUT}"

        sleep 15
    )&
    asyncproc_handlers[${#asyncproc_handlers[*]}]=$!
    asyncproc_say "Stdout handler has been started as ${asyncproc_handlers[-1]}" 
}

asyncproc_handler_stdout_init() {
    asyncproc_handler_stdout_conf
    declare -F asyncproc_handler_stdout_conf_local &> /dev/null && asyncproc_handler_stdout_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_HANDLER_STDOUT_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_HANDLER_STDOUT_INPUT}"
}

asyncproc_handler_stdout_conf() {
    asyncproc_handler_stdout_pid="0"
    export ASYNCPROC_HANDLER_STDOUT_INPUT="/tmp/${asyncproc_basename}-asyncproc-stdout.pipe"
}

asyncproc_handler_stdout_exit() {
    rm -f ${ASYNCPROC_HANDLER_STDOUT_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_HANDLER_STDOUT_INPUT}"
    asyncproc_say "Stdout handler has exited"
}


# --- Stderr handler ---
asyncproc_handler_stderr_start() {
    asyncproc_handler_stderr_init
    (
        trap asyncproc_handler_stderr_exit EXIT
        asyncproc_namespace="stderr"
        asyncproc_say "Ready to receive stderrs at ${ASYNCPROC_HANDLER_STDERR_INPUT}"

        sleep 16
    )&
    asyncproc_handlers[${#asyncproc_handlers[*]}]=$!
    asyncproc_say "Stderr handler has been started as ${asyncproc_handlers[-1]}" 
}

asyncproc_handler_stderr_init() {
    asyncproc_handler_stderr_conf
    declare -F asyncproc_handler_stderr_conf_local &> /dev/null && asyncproc_handler_stderr_conf_local || :

    mkfifo -m 600 ${ASYNCPROC_HANDLER_STDERR_INPUT} &> /dev/null || asyncproc_die "Cannot create ${ASYNCPROC_HANDLER_STDERR_INPUT}"
}

asyncproc_handler_stderr_conf() {
    asyncproc_handler_stderr_pid="0"
    export ASYNCPROC_HANDLER_STDERR_INPUT="/tmp/${asyncproc_basename}-asyncproc-stderr.pipe"
}

asyncproc_handler_stderr_exit() {
    rm -f ${ASYNCPROC_HANDLER_STDERR_INPUT} || asyncproc_err "Cannot remove ${ASYNCPROC_HANDLER_STDERR_INPUT}"
    asyncproc_say "Stderr handler has exited"
}

# --- Common functions ---
asyncproc_say() {
    [ "${ASYNCPROC_VERBOSE}" = "true" ] && eval echo "${asyncproc_say_pre}$@${asyncproc_say_suf}"
}

asyncproc_err() {
    [ "${ASYNCPROC_ERRORS}" = "true" ] && asyncproc_say "${asyncproc_err_pre}$@${asyncproc_err_suf}" >&2
}

asyncproc_die() {
    asyncproc_err "${asyncproc_die_pre}$@${asyncproc_die_suf}"
    exit ${asyncproc_die_exitcode}
}

asyncproc_term_procs() {
    local _timeout _pid_k _pids=() _watchdog=()

    _timeout=$1; shift
    read -a _pids <<< "$@"

    while [[ -n "${!_pids[*]}" ]]; do
        for _pid_k in ${!_pids[*]}; do
            if [[ -z "${_pids[${_pid_k}]}" ]] || [[ ${_pids[${_pid_k}]} -eq 0 ]]; then
                unset _pids[${_pid_k}]
                continue
            fi
            

            if ps -p ${_pids[${_pid_k}]} &>/dev/null; then
                if [[ -n "${_watchdog[${_pids[${_pid_k}]}]}" ]] && [[ ${_watchdog[${_pids[${_pid_k}]}]} -gt 0 ]]; then
                    :
                else
                    kill -TERM ${_pids[${_pid_k}]}
                    ( sleep ${_timeout}; kill -KILL ${_pids[${_pid_k}]} )&
                    # saving watchdog's PID in the index of process' PID
                    _watchdog[${_pids[${_pid_k}]}]=$!
                fi
            else 
                ps -p ${_watchdog[${_pids[${_pid_k}]}]} &>/dev/null && kill -TERM ${_watchdog[${_pids[${_pid_k}]}]}
                unset _wd[${_pids[${_pid_k}]}]
                unset _pids[${_pid_k}]
            fi
        done
        sleep 1
    done

}
